# 靜態連結(static linking)

gcc一般編譯時，使用的是動態連結，如果要使用靜態連結時，要加上`-static`參數。

* `gcc -c hello.c -o hello // dynamic linking`
* `gcc -static -c hello.c -o hello // static linking`

## 連結(linking)

**連結指在程式的各模組之間傳遞引數和控制命令，並把它們組成一個可執行的整體的過程**。

在編寫程式的時候，程式設計師把每個原始碼模組獨立的進行編譯，然後按照需要將它們組裝起來，這個組裝模組的過程就是連結。這一過程就好像拼圖一樣，各個模組間依靠符號來通訊，定義符號的模組多出一塊區域，引用該符號的模組剛好少了那一塊區域，兩者拼接，形成完美組合。

比如我們程式模組a.c中使用另外一個模組中的函式如`printf()`函式。我們在a.c模組中每一次呼叫`printf()`的函式時候都必須知道`printf()`這個函式的地址，但是由於每個模組都是單獨編譯的，編譯器在編譯a.c的時候無法得知`printf()`函式的地址，所以暫時將目標地址擱置。

假設不使用連結器，我們需要手工的對`printf()`地址進行修正，這個工作量是巨大的，而且一旦`printf()`模組重新編譯，函式地址也要相對應調整。這種方法顯然是不可取的。使用連結器可以規避這一切，當連結器在連結的時候，會根據你所引用的符號`printf`，自動去相應模組去尋找`printf()`函式地址，然後在a.c模組中所有引用`printf()`函式的指令重新修正。這就是靜態連結的最基本過程和作用。

## 靜態函式庫(static library)

在連結階段，會將組合語言生成的目標檔案.o與引用到的函式庫一起連結打包到可執行檔案(.out)中。試想一下，靜態函式庫之所以能與組語生成的目標檔案一起連結為可執行檔案，說明靜態函式庫的格式必定跟.o檔案格式相似。

其實一個靜態庫可以簡單看成是一組物件檔案（.o 檔案）的集合，即很多物件檔案經過壓縮打包後形成的一個檔案。

在linux中，靜態函式庫通常是`.a`結尾的檔案，可用`ar -t lib.a`工具查看函式庫包含那些物件檔案。

### 優點

靜態函式庫的連結是放在編譯時期完成，程式在執行時與函式庫再無瓜葛，移植方便，執行速度快。

### 缺點

最明顯的就是浪費空間和資源，靜態連結方式對於計算機記憶體和磁碟的空間浪費十分嚴重。因為許多程式會包含大量相同的公共程式碼，造成浪費。

另一個問題是靜態庫對程式的更新比較麻煩，如果靜態庫`libc.a`更新了，所有使用它的應用程式都需要重新編譯，儘管有時候只是一個小小的改動。
