# 保護模式\(protect mode\)

## Intel architecture架構概觀

Intel CPU架構又稱 x86 架構，因為它的第一代處理器的代號是 8086，而其後繼產品依序以 8088、80186、80188、80286……為代號，均為 80x86 的形式；而在 80286 之後，Intel 改以 i386、i486 來命名，因此才被稱為 x86 架構。在 i486 處理器之後，Intel 就不再以 x86 的形式命名，所以在這裡以較正式的 Intel Architecture 來稱呼這個架構（簡稱 IA 架構）。

Intel Architecture 系列的處理器中，最早的 8086 是一 16 bit 的處理器，具有 16 bit 的暫存器和資料匯流排，並具有 20 bit 的定址能力，能定址最多達 1MB 的記憶體。然而，20 bit 的位址和 16 bit 的暫存器無法相符，因此 Intel 設計了一種 **segment:offset** 的定址方式，利用兩個 16 bit 暫存器來表示一個 20 bit 的位址。

到了 80286 的時代，1MB 的定址能力已經不敷使用，因此 Intel 為它設計了一個新的「保護模式」（Protected Mode），並將原先 8086 所使用的方式稱為「真實模式」（Real Mode）。80286 具有 24 bit 的定址能力，可以定址 16MB 的記憶體，但是只有在保護模式下才能發揮。在真實模式中，為了維持和 8086 的相容性，還是只能使用 1MB 的記憶體。80286 的保護模式已經有了多工作業的能力，並且可以保護各個節區的資料和程式不被其它程式干擾。

在 i386 出現時，情形有很大的變化。i386 是一個 32 bit 的處理器，並具有 32 bit 的定址能力，可以定址達 4GB 的記憶體。它同時也改進了 80286 不完整的的保護模式，提供了很多新的功能，如虛擬記憶體等等。一般所說的「保護模式架構」，就是指 i386 的保護模式。

## IA-32 的操作模式

在 i386 以後的 Intel Architecture 相容處理器（統稱 IA-32 架構），具有四種操作模式：

* **真實模式（Real Mode）**：在這個模式下，處理器的行為和的 8086 一般。
* **（32 bit）保護模式（Protected Mode）**：在這個模式下，處理器具有多工、分節保護、分頁等等的能力。
* **虛擬 8086 模式（Virtual-8086 Mode）**：這個模式是在一般的保護模式下，模擬一個 8086 的執行環境，可以同時執行多個 8086 程式。
* **系統管理模式（System Management Mode, SMM）**：這個模式會使處理器切換到一個獨立的定址空間中執行，通常在電源管理之類的系統工作才會使用這個模式。

而在保護模式中，有四個重要的部分：記憶體管理、保護機制、中斷／例外處理、和多工處理。

### 系統暫存器

在處理器中有一些暫存器，是用來控制系統的一些行為的，這些暫存器通常只有作業系統會使用。這些暫存器中，和保護模式有關的，有：

* **EFLAGS** 中（32 bit 的旗標暫存器）的一些系統旗標和 IOPL 欄位。在保護模式中，只有 CPL 小於或等於 IOPL 的程式才存取 I/O 位址空間，和進行一些其它的操作。
* **控制暫存器（Control Registers）**，包括 CR0、CR2、CR3、CR4（CR1 保留）。這些暫存器包括一些和保護模式關係密切的內容（例如，是否進入保護模式、是否開啟分頁功能等等）。
* **GDTR、LDTR、和 IDTR**。這三個暫存器存放三個系統的 descriptor table 的基底位址和邊界（大小）。
* 工作暫存器（Task Register）存放目前工作（task）的 TSS 的基底位址和大小。

## 定址方式

在保護模式中，有三種定址方式：

* 邏輯位址（Logical Address）
* 線性位址（Linear Address）
* 實體位址（Physical Address）

對大部分的應用程式而言，幾乎只會用到邏輯位址。線性位址和實體位址在大部分的情形中，只有作業系統會使用。

### 實體位址

所謂的「實體位址」，就是指系統的記憶體的真正位址，它的範圍由 00000000H 到 FFFFFFFFH，共有 4GB。大部分情形中，系統的 RAM 都是由 00000000H 開始定址（即在最底端），而 ROM 則由 FFFFFFFFH 開始定址（即在最頂端）。這是因為在 RESET 之後，處理器會從定址空間的頂端開始執行，所以把 ROM 定址在頂端才能讓處理器在 RESET 後執行到開機用的程式（如開機自我測試之類的程式）。

### 線性位址

**在沒有使用分頁（Paging）功能的時候，線性位址是直接對映到實體位址的**。也就是說，線性位址就等同於實體位址。

不過，**在開啟分頁分能之後，一個線性位址可能沒有相對映的實體位址**（因為它所對映的記憶體可能被 swap 到硬碟裡了）。所謂的分頁功能，是指把定址空間分割成許多頁，而實際的記憶體可能無法容納這麼多頁，因此有些頁若暫時沒有用到，就可以暫時存放到硬碟（或其它儲存媒體）中，等到需要的時候再取出來。這個功能可以讓系統使用比實際的 RAM 空間更大的記憶體。因此，在這種情形下，一個線性位址所在的頁可能還在硬碟中，因此，要存取這個位址，就要先把 swap 到硬碟中的資料取出，放到實體記憶體中的某個位置中（這時，可能有些頁就得讓開位置，被 swap 到硬碟中了）。

### 邏輯位址

**而邏輯位址則和真實模式類似，仍然是 segment:offset 的形式**，只不過現在 offset 的大小改成 32 bit 而已，而 segment 仍然是 16 bit。

不過，和真實模式不同的是，segment 的意義不同；在保護模式中，segment 的位置不再是固定的，而是可以自由決定的。

Segment 暫存器（稱為 Segment Selector）則是用來選擇想要使用的 segment。同時，**在保護模式中，segment 也可以有大小限制**，不像在真實模式中，一個 segment 一定是 64KB\(16 bit的上限\)（雖然 segment 的實際大小可以比 64KB 小，但是處理器並不會檢查存取動作是否超出了 segment 的範圍）。

**在保護模式中，每一個 segment 都有一個 segment descriptor，描述這個 segment 的位置、大小、型態、存取權限等等資料。**Segment 的位置是以「基底位址」來表示，基底位址是一個線性位址。要存取 segment 中的某個位址，需要指定一個 offset 位址，而實際的線性位址則是將 segment 的基底位址加上 offset 就可以得到。

![](../.gitbook/assets/linear_and_logical_address.gif)

