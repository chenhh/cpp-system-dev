# 變數與類型

## 變數宣告

Rust的變數必須先聲明後才能使用，預設是唯讀不可寫入，與C/C++中變數預寫為可讀寫不同。

```rust
fn main() {
   let x: i32 = 100;  // type i32可省略，由編譯器自動推斷type
   //x = 80;          // error, x不可變
   println!("x={}", x);
}

fn main() {
    let x; // type i32可省略，由編譯器自動推斷type
    x = 100; // 此處為初始化，而非賦值
    //x = 80;  // error, x不可變
    println!("x={}", x);
}

/* Rust中，每個變數必須被合理初始化之後才能被使用。
 * 使用未初始化變數這樣的錯誤，在Rust中是不可能出現的。
 */
fn main() {
    let x: i32;        // 未初始化的變數
    println!("{}", x); // compile error
}
```

區域變數聲明一定是以關鍵字let開頭，類型一定是跟在冒號：的後面。語法歧義更少，語法分析器更容易編寫。

因為在變數聲明語句中，最重要的是變數本身，而類型其實是個附屬的額外描述，並非必不可少的部分。**如果我們可以通過上下文環境由編譯器自動分析出這個變數的類型，那麼這個類型描述完全可以省略不寫**。Rust一開始的設計就考慮了類型自動推導功能，因此類型後置的語法更合適。

類型沒有“預設構造函數”，變數沒有“預設值”。對於`let x：i32`；如果沒有顯式賦值，它就沒有被初始化，不要想當然地以為它的值是0。

```rust
fn main() {
    let mut x = 100; // 關鍵字mut說明x可讀寫
    x = 80;          // 改變x之值, i32有實作copy trait，因此為copy而非move
    println!("x={}", x); //80
}

fn main() {
    let (mut a, mut b) = (1, 2); //pattern destructure
    a = 3;
    b = 4;
    println!("a={}, b={}", a, b); //a=3, b=4
}
```

如果我們需要讓變數是可寫的，那麼需要使用mut關鍵字，我們不能把let mut視為一個組合，而應該將mut x視為一個組合。

Rust內的型別如果沒有實作copy trait時\(只有基礎型別可實作\)，賦值運算子`=`預設為move語意。

Rust裡面的底線`_`是一個特殊的識別字，在編譯器內部它是被特殊處理的。它跟其他識別字有許多重要區別。

## 變數遮蔽\(variable shadowing\)

Rust允許在同一個程式碼塊中聲明同樣名字的變數。如果這樣做，後面聲明的變數會將前面聲明的變數“遮蔽”（Shadowing）起來。**但被遮蔽的變數的生命週期不受影響，即不會因為被遮蔽而提早結束**。

```rust
fn main() {
    let x = "hello";        //唯讀的變數, 型別為&str
    println!("x is {}", x); // hello
    let x = 5;              // shadowing而非賦值, 可視為重新宣告一個同名的變數
    println!("x is {}", x); // 5
}

/* 由可寫入變數變為唯讀變數 */
fn main() {
    let mut v = Vec::new(); // v 必須是mut修飾,因為我們需要對它寫入資料
    v.push(1);
    v.push(2);
    v.push(3);
    let v = v; // 從這裡往下,v成了唯讀變數,可讀寫變數v已經被遮蔽,無法再訪問
    for i in &v {
        println!("{}", i);
    }
}

/* 由唯讀變數變為可寫入變數 */
fn main() {
    let v = Vec::new();
    let mut v = v;  // 由唯讀變為可寫入
    v.push(1);
    println!("{:?}", v);
}
```

但是這兩個`x`代表的記憶體空間完全不同，類型也完全不同，它們實際上是兩個不同的變數。從第4行開始，一直到這個程式碼塊結束，我們沒有任何辦法再去訪問前一個`x`變數，因為它的名字已經被遮蔽了。

變數遮蔽在某些情況下非常有用，比如，我們需要在同一個函數內部把一個變數轉換為另一個類型的變數，但又不想給它們起不同的名字。再比如，在同一個函數內部，需要修改一個變數綁定的可變性。

C/C++中也存在類似的功能，只不過它們只允許嵌套的區域內部的變數出現遮蔽。而Rust在這方面放得稍微寬一點，同一個語句塊內部聲明的變數也可以發生遮蔽。

## 類型推導

Rust的類型推導功能是比較強大的。它不僅可以從變數聲明的當前語句中獲取資訊進行推導，而且還能通過上下文資訊進行推導。

自動類型推導和“動態類型系統”是兩碼事。**Rust依然是靜態類型的**。一個變數的類型必須在編譯階段確定，且無法更改，只是某些時候不需要在程式碼中顯式寫出來而已。

```rust
fn main() {
    // 沒有明確標出變數的類型,但是通過字面量的尾碼,
    // 編譯器知道elem的類型為u8
    let elem = 5u8; // 也可寫5_u8, 底線不影響數值定義
                    // 創建一個動態陣列,陣列內包含的是什麼元素類型可以不寫
    let mut vec = Vec::new();
    vec.push(elem);
    // 到後面調用了push函數,通過elem變數的類型,
    // 編譯器可以推導出vec的實際類型是 Vec<u8>
    println!("{:?}", vec);
}
```

我們甚至還可以只寫一部分類型，剩下的部分讓編譯器去推導，比如下面的這個程式，我們只知道players變數是Vec動態陣列類型，但是裡面包含什麼元素類型並不清楚，可以在尖括弧中用底線來代替。

```rust
fn main() {
    let player_scores = [("Jack", 20), ("Jane", 23), ("Jill", 18), ("John", 19)];
    // players 是動態陣列,內部成員的類型沒有指定,交給編譯器自動推導
    let players: Vec<_> = player_scores
        .iter()
        .map(|&(player, _score)| player)
        .collect();
    println!("{:?}", players);
}
```

