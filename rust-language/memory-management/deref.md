# 解引用\(deref\)

## 簡介

引用是對記憶體塊的借用，Rust裡每一個記憶體塊都是有主人的，主人就是對記憶體擁有所有權的變數，**沒有主人的記憶體塊我們稱之為記憶體洩露了**。

**解引用是通過引用找到記憶體塊真正的主人**，然後你可以跟主人借一些不同型別的引用，比如從`&mut T`借成`Pin<&mut T>`。

這個主人可能被包了很多層，當你以為你找了主人，其實它只是個皮，所以會存在不斷解引用的情況，你可能需要加很多個\*，當然很多個\*不符合設計美感。

**Rust語法規定，同一塊記憶體只能有一個可變引用，或者有多個不可變引用（共享不可變，可變不共享）**。**Rust之所以這麼規定，一個非常大的優點是避免了記憶體被多處修改的潛在隱患，避免了資源的複雜環境競爭，降低了程式的除錯難度**。

那麼，程式編寫過程中必然會在不同的函式塊裡呼叫同一塊記憶體，所以引用的使用將會變得非常頻繁，我們犯的錯誤大多也在此。

```rust
fn main() {
    let v1 = 1;
    let p = &v1; //取引用操作
    let v2 = *p; //解引用操作
    println!("{} {}", v1, v2); // 1, 1
}
```

## 自動解引用和手動解引用

* 自動解引用：Rust為了減少某些場合下重複解引用導致的程式碼美觀問題，在編譯期做了一些智慧識別功能，比如帶有`&T`引數的函式被呼叫的時候，你傳`&&&......&&&T`都可以自動解引用，直到符合函式的引數型別為止。
* 手動解引用，就是和其他語言類似，借用是`&`操作符，解引用是`*`操作符。

我們也可以通過自行實現Deref這個Trait來自定義解引用的最終目標是什麼，而恰恰這個也是Rust語言最難的地方，你得瞭解每個型別是否實現了Deref，而Rust型別實在是太多了，連&T借用也算一個新的型別，&T是不能繼承T的所有特性的。

