# 借用和生命週期

## 生命週期\(lifetime\)

一個變數的生命週期就是它從創建到銷毀的整個過程。生命週期在必要時可以顯式標記。

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5]; // --> v 的生命週期開始
    {
        let center = v[2];       // --> center 的生命週期開始
        println!("{}", center);
    }                            // <-- center 的生命週期結束
    println!("{:?}", v);
}                                // <-- v 的生命週期結束
```

## 借用\(borrow\)

如果一個變數永遠只能有唯一一個入口可以訪問的話，那就太難使用了。因此，所有權還可以借用。

借用指標的語法使用**&符號\(唯讀\)**或者**&mut符號**\(可讀寫\)表示。前者表示唯讀借用，後者表示可讀寫借用。**借用指標（borrow pointer）也可以稱作“引用”（reference）**。借用指標與普通指標的內部資料是一模一樣的，唯一的區別是語義層面上的。它的作用是告訴編譯器，它對指向的這塊記憶體區域沒有所有權。

```rust
// 我們需要“可變的”借用指標,因此函數簽名需要改變
fn foo(v: &mut Vec<i32>) {
    v.push(5);
}
fn main() {
    // 我們需要這個動態陣列本身是“可變的”,才能獲得它的“可變借用指針”
    let mut v = vec![];
    // 在函式呼叫的時候,同時也要顯示獲取它的“可變借用指針”
    foo(&mut v);
    // 列印結果,可以看到v已經被改變
    println!("{:?}", v);
}
```

對於&mut型指針，要注意不要混淆它與變數綁定之間的語法。

* 如果mut修飾的是變數名，那麼它代表這個變數可以被重新綁定；\(但指向的物件不能被修改\)
* 如果mut修飾的是“借用指標&”，那麼它代表的是被指向的物件可以被修改。\(但變數不能被修改\)

## 借用規則

* 借用指標不能比它指向的變數存在的時間更長。
  * **借用指標只能臨時地擁有對這個變數讀或寫的許可權，沒有義務管理這個變數的生命週期。**因此，借用指標的生命週期絕對不能大於它所引用的原來變數的生命週期，否則就是懸空指標，會導致記憶體不安全。
* `&mut`型借用只能指向本身具有`mut`修飾的變數，對於唯讀變數，不可以有`&mut`型借用。
* `&mut`型借用指標存在的時候，被借用的變數本身會處於“凍結”狀態，即被借用的變數不可被存取。
* \[共享不可變\] 如果只有`&`型借用指針，那麼能同時存在多個；

  * \[可變不共享\] 如果存在`&mut`型借用指標，那麼只能存在一個；
  * 如果同時有其他的`&`或者`&mut`型借用指針存在，那麼會出現編譯錯誤。

## 參考資料

* [\[知乎\] 理解 Rust 引用和借用](https://zhuanlan.zhihu.com/p/59998584)

