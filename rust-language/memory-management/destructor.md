# 解構函數\(destructor\)

## 簡介

所謂“解構函數”（destructor），是與“構造函數”（constructor）相對應的概念。**“構造函數”是物件被創建的時候調用的函數，“解構函數”是物件被銷毀的時候調用的函數**。

Rust中沒有統一的“構造函數”這個語法，物件的構造是直接對每個成員進行初始化完成的，我們一般將物件的創建封裝到普通靜態函數中（通常命名為new）。

相對於構造函數，**解構函數有更重要的作用。它會在物件消亡之前由編譯器自動調用，因此特別適合承擔物件銷毀時釋放所擁有的資源的作用**。比如，Vec類型在使用的過程中，會根據情況動態申請記憶體，當變數的生命週期結束時，就會觸發該類型的解構函數的調用。

在解構函數中，我們就有機會將所擁有的記憶體釋放掉。在解構函數中，我們還可以根據需要編寫特定的邏輯，從而達到更多的目的。解構函數不僅可以用於管理記憶體資源，還能用於管理更多的其他資源，如檔案、鎖、socket等。

**在C++中，利用變數生命週期綁定資源的使用週期，已經是一種常用的程式設計慣例。此手法被稱為RAII（Resource Acquisition Is Initialization）**。在變數生命週期開始時申請資源，在變數生命週期結束時利用解構函數釋放資源，從而達到自動化管理資源的作用，很大程度上減少了資源的洩露和誤用。在Rust中編寫“解構函數”的辦法是impl [std::ops::Drop](https://doc.rust-lang.org/std/ops/trait.Drop.html)。

```rust
pub trait Drop {
    fn drop(&mut self);
}
```

