# 生命週期\(lifetime\)

## 生命週期\(lifetime\)

一個變數的生命週期就是它從創建到銷毀的整個過程。生命週期在必要時可以顯式標記。

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5]; // --> v 的生命週期開始
    {
        let center = v[2];       // --> center 的生命週期開始
        println!("{}", center);
    }                            // <-- center 的生命週期結束
    println!("{:?}", v);
}                                // <-- v 的生命週期結束
```

## 生命週期標記

對一個函數內部的生命週期進行分析，Rust編譯器可以很好地解決。但是，當生命週期跨函數的時候，就需要一種特殊的生命週期標記符號了。

## 函數的生命週期標記

```rust
struct T {
    member: i32,
}

fn test<'a>(arg: &'a T) -> &'a i32 {
    &arg.member
}

fn main() {
    let t = T { member: 0 }; //----- 't -|
    let x = test(&t);        //-- 'x ---| |
    println!("{:?}", x);     // | |
}
```

生命週期符號使用單引號開頭，後面跟一個合法的名字。生命週期標記和泛型類型參數是一樣的，都需要先聲明後使用。在上面這段程式碼中，尖括弧裡面的`'a`是聲明一個生命週期參數，它在後面的參數和返回值中被使用。

借用指標類型都有一個生命週期泛型參數，它們的完整寫法應該是`&'a T&'a mut T`，只不過在做區域變數的時候，生命週期參數是可以省略的。

生命週期之間有重要的包含關係。如果生命週期`'a`比`'b`更長或相等，則記為`'a:'b`，意思是`'a`至少不會比`'b`短，英語讀做“lifetime aoutlives lifetime b”。對於借用指標類型來說，如果`&'a`是合法的，那麼`'b`作為`'a`的一部分，`&'b`也一定是合法的。

另外，`'static`是一個特殊的生命週期，它代表的是這個程式從開始到結束的整個階段，所以它比其他任何生命週期都長。這意味著，任意一個生命週期`'a`都滿足`'static：'a`。

## 類型的生命週期標記

如果自訂類型中有成員包含生命週期參數，那麼這個自訂類型也必須有生命週期參數。

```rust
struct Test<'a> {
    member: &'a str,
}
```

在使用impl的時候，也需要先聲明再使用：

```rust
impl<'t> Test<'t> {
    fn test<'a>(&self, s: &'a str) {}
}
```

impl後面的那個`'t`是用於聲明生命週期參數的，後面的`Test<'t>`是在類型中使用這個參數。如果有必要的話，方法中還能繼續引入新的泛型參數。

如果在泛型約束中有`where T:'a`之類的條件，其意思是，類型`T`的所有生命週期參數必須大於等於`'a`。要特別說明的是，若是有`where T:'static`的約束，意思則是，類型`T`裡面不包含任何指向短生命週期的借用指標，意思是要麼完全不包含任何借用，要麼可以有指向`'static`的借用指標。

## 省略生命週期標記

在某些情況下，Rust允許我們在寫函數的時候省略掉顯式生命週期標記。在這種時候，編譯器會通過一定的固定規則為參數和返回值指定合適的生命週期，從而省略一些顯而易見的生命週期標記。

```rust
fn get_str(s: &String) -> &str {
    s.as_ref()
}

// 顯式標記生命週期
fn get_str<'a>(s: &'a String) -> &'a str {
    s.as_ref()
}
```

編譯器對於省略掉的生命週期，不是用的“自動推理”策略，而是用的幾個非常簡單的“固定規則”策略。這跟類型自動推導不一樣，當我們省略變數的類型時，編譯器會試圖通過變數的使用方式推導出變數的類型，這個過程叫“type inference”。

而對於省略掉的生命週期參數，編譯器的處理方式就簡單粗暴得多，它完全不管函數內部的實現，並不嘗試找到最合適的推理方案，只是應用幾個固定的規則而已，這些規則被稱為**“lifetime elision rules”**。以下就是省略的生命週期被自動補全的規則：

* 每個帶生命週期參數的輸入參數，每個對應不同的生命週期參數；
* 如果只有一個輸入參數帶生命週期參數，那麼返回值的生命週期被指定為這個參數；
* 如果有多個輸入參數帶生命週期參數，但其中有&self、&mutself，那麼返回值的生命週期被指定為這個參數；
* 以上都不滿足，就不能自動補全返回值的生命週期參數。

```rust
fn get_str(s: &String) -> &str {
    println!("call fn {}", s);
    "hello world"
}
// 編譯器會自動補全生命週期參數
fn get_str<'a>(s: &'a String) -> &'a str {
    println!("call fn {}", s);
    "hello world"
}
```

