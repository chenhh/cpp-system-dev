# 所有權與移動\(ownership and move\)

## 所有權\(ownership\)

“所有權”代表著以下意義：

* 每個值在Rust中都有一個變數來管理它，這個變數就是這個值、這塊記憶體的所有者；
* 每個值在一個時間點上只有一個管理者；
* 當變數所在的作用域結束的時候，變數以及它代表的值將會被銷毀。

```rust
fn main() {
    let mut s = String::from("hello");
    // 因為對s有寫入的操作，因此必須宣告為mut S
    s.push_str(" world");
    println!("{}", s);
}
```

* 當我們聲明一個變數s，並用String類型對它進行初始化的時候，這個變數s就成了這個字串的“所有者”。
* 如果我們希望修改這個變數，可以使用mut修飾s，然後調用String類型的成員方法來實現。
* 當main函數結束的時候，s將會被解構，它管理的記憶體（不論是堆積上的，還是堆疊上的）則會被釋放。
* 我們一般把變數從出生到死亡的整個階段，叫作一個變數的“生命週期”（lifetime）。比如這個例子中的區域變數s，它的生命週期就是從let語句開始，到main函數結束。

```rust
fn main() {
    let s = String::from("hello");
    let s1 = s;
    // error, borrow of moved value: `s`
    // 因為s對String的所有權已經轉移給s1，
    // s的生命週期結束, 不可再被使用
    // 解法：改用borrow，let s1 = &s;
    // 解法：改用clone, let s1 = s.clone();
    println!("{}", s);
}
```

在Rust裡面，不可以做“設定運算子重載”，若需要“深複製” \(deep copy\)（指的是對於複雜結構中所有元素的複製，而不是單純以共享指標指向該結構），必須手工調用clone方法。這個clone方法來自於std:clone::Clone這個trait。clone方法裡面的行為是可以自訂的。

## 移動語意\(move\)

一個變數可以把它擁有的值轉移給另外一個變數，稱為“所有權轉移”。設定陳述式、函式呼叫、函數返回等，都有可能導致所有權轉移。

**Rust中所有權轉移的重要特點是，它是所有類型的預設語義**。Rust中的變數綁定操作，預設是move語義，執行了新的變數綁定後，原來的變數就不能再被使用！一定要記住！

```rust
fn create() -> String {
    let s = String::from("hello");
    return s; // 所有權轉移,從函數內部移動到外部
}
fn consume(s: String) {
    // 所有權轉移,從函數外部移動到內部
    println!("{}", s);
}
fn main() {
    let s = create();
    consume(s);
}
```

所有權轉移的步驟分解如下。

1. main函式呼叫create函數。
2. 在調用create函數的時候創建了字串，在堆疊上\(s\)和堆積上\(hello\)都分配有記憶體。區域變數s是這些記憶體的所有者。
3. create函數返回的時候，需要將區域變數s移動到函數外面，這個過程就是簡單地按位元組複製memcpy。
4. 同理，在調用consume函數的時候，需要將main函數中的區域變數轉移到consume函數，這個過程也是簡單地按位元組複製memcpy。
5. 當consume函數結束的時候，它並沒有把內部的區域變數再轉移出來，這種情況下，consume內部區域變數的生命週期就該結束了。這個區域變數s生命週期結束的時候，會自動釋放它所擁有的記憶體，因此字串也就被釋放了。

C++的做法就不一樣了，它允許賦值構造函數\(copy constructor\)、設定運算子\(assignment operator\)重載，因此在出現“構造”或者“賦值”操作的時候，有可能表達的是完全不同的含義，這取決於程式設計師如何實現重載。C++的這個設計具有巨大的靈活性，但是不恰當的實現也可能造成記憶體不安全。

在C++裡面，`std::vector<int>v1=v2`；是複製語義，而Rust裡面的`let v1:Vec<i32>=v2`；是移動語義。如果要在Rust裡面實現複製語義，需要顯式寫出函式呼叫`let v1:Vec<i32>=v2.clone()`；

“語義”不代表最終的執行效率。“語義”只是規定了什麼樣的程式碼是編譯器可以接受的，以及它執行後的效果可以用怎樣的思維模型去理解。編譯器有權在不改變語義的情況下做任何有利於執行效率的優化。語義和優化是兩個階段的事情。我們可以把移動語義想像成執行了一個memcpy，但真實的組譯代碼未必如此。

編譯器可以提前在當前調用堆疊中把大物件的空間分配好，然後把這個物件的指標傳遞給子函數，由子函數執行這個變數的初始化。這樣就避免了大物件的複製工作，參數傳遞只是一個指標而已。這麼做是完全滿足移動語義要求的，而且編譯器還有權利做更多類似的優化。

## 複製語意\(copy\)

* 此處的複製指的是隱式的copy，而非顯式的clone。
* move可以類比成作業系統中的剪下\(或移動\)操作，移動後，原始的資料就不可再被使用。

預設的move語義是Rust的一個重要設計，但是任何時候需要複製都去調用clone函數會顯得非常煩瑣。對於一些簡單類型，比如整數、bool，讓它們在賦值的時候默認採用複製操作會讓語言更簡單。

```rust
fn main() {
    let v1: isize = 0;
    // 基本類型有實作copy trait,
    // =運算子會使用copy而非move
    // 所有權沒有被轉移，
    // v2和v1指向的是不同記憶體地址
    let v2 = v1;
    println!("{}", v1); // 0
    // 因為是複製，所以指向相異記憶體地址
    println!("{:p}, {:p}", &v1, &v2);
}
```

因為在Rust中有一部分特殊的類型，其變數綁定操作是copy語義。**所謂的copy語義，是指在執行變數綁定操作的時候，v2是對v1所屬資料的一份複製。v1所管理的這塊記憶體依然存在，並未失效，而v2是新開闢了一塊記憶體，它的內容是從v1管理的記憶體中複製而來的**。

和手動調用clone方法效果一樣，`let v2=v1；`等效於`let v2=v1.clone（）；`。使用檔案系統來打比方。

* copy語義就像“複製、粘貼”操作。操作完成後，原來的資料依然存在，而新的資料是原來資料的複製品。
* move語義就像“剪切、粘貼”操作。操作完成後，原來的資料就不存在了，被移動到了新的地方。

這兩個操作本身是一樣的，都是簡單的記憶體複製，區別在於複製完以後，原先那個變數的生命週期是否結束。

Rust中，在普通變數綁定、函數傳參、模式匹配等場景下，凡是實現了`std::marker::Copy` trait的類型，都會執行copy語義。**基本類型，比如整數、浮點數、字元、bool等，都實現了Copy trait，因此具備copy語義。對於自訂類型，預設是沒有實現Copy trait的，但是我們可以手動實現**。

