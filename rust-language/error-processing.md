# 錯誤處理

## 簡介

返回錯誤類型，這種錯誤處理機制其實最早是C語言就有了。

因為C語言缺乏高級語言的異常處理機制，所以只能用返回值、goto、setjump、assert等方式來處理程式中的錯誤。這種方式的優點就是非常靈活。

但缺點更多。在C語言裡，使用返回值等方式來處理錯誤，實際上很容易變成Bug的溫床，因為沒有強制性的檢查，很容易被開發者疏忽。另外，可讀性非常差，處理錯誤的代碼和正常代碼交織在一起，陷入「錯誤地獄」。

隨著C++、java等語言發展，才引入了異常處理機制，因此有Try/Catch這種用法。利用stack unwind機制來自動處理異常，解放了開發者。優點是，它是全域性且獨立的，不需要所有函數都考慮捕獲異常。並且用專門的異常處理語法將正常邏輯和異常處理隔離開來。但異常處理其實並不完美。

異常處理的開銷是很大的，尤其是throw的時候。另外異常處理包含的資訊太多，對於開發者來說，如何優雅地處理異常，是另外一個難題了。

其實在實際開發中，錯誤是可以分為以下三類的：

* **失敗**：違反契約的情況。比如函數參數需要的是字串，你傳入了數字類型，這是一種違反契約的情況。
* **錯誤**：一般是在意料中可能出現問題的地方出現了問題。比如http鏈接超時，訪問了不存在的檔案等。這些錯誤其實是開發者可以處理的。但是在那些異常處理語言中，把失敗和錯誤，都歸到了異常中，粒度非常粗。
* **異常**：真正的異常，是指完全不可預料的問題。比如NullError，訪問了越界的數組等等，基本是開發者無法處理的情況。

Rust語言在這方面則做的非常精緻。

* 處理失敗：Option&lt;T&gt;，豐富的斷言巨集，顯式類型的函數簽名，編譯器內置的各種檢查。
* 處理錯誤： Result&lt;T, E&gt;, Error trait，各種組合子方法方便傳播錯誤。最關鍵的是，即便是IO處理，也是這種純錯誤處理方式，而非異常。
* 恐慌：發生恐慌線程即崩潰。比如內存用盡這種情況。也提供了catch\_unwind的方法來捕獲恐慌，恢復線程，但是為了內存安全，只有實現了UnwindSafe的類型才能安全catch。

在Safe Rust中基本可以保證異常安全，但是unsafe rust中則需要開發者來保證。即便如此，unsafe rust中也有種種限制不會隨便暴露記憶體。

Rust 並沒有提供基於 exception 的錯誤處理機制，雖然 panic! 巨集在讓行程掛掉時也拋出堆疊，同時也可以用 `std::panic::catch_unwind` 捕捉 panic，但是極其不推薦用來處理常規錯誤。



## 主流模式：try-catch-finally

你學會了某種語言的try/catch，對這套機制的理解就能夠遷移到其他語言上了。除了C++沒有finally關鍵字外，像C\#、Python、Java都有基本一致的異常處理邏輯：

* try塊包住可能會出現的異常；
* 用catch將之捕獲；
* finally塊統一處理資源的清理；
* 對於自定義的函數，我們可以throw異常。

在這種異常處理系統中，對異常的定義是比較寬泛的：意料之外，情理之中。正是“異常”在語義上的模糊性，才產生了很多最佳實踐來指導異常的使用。從“正常到異常的程度”上，大致上可以歸為4類：

### 0 正常：不要用異常來進行流程控制，異常只用來處理“意外”。

這條教導告訴我們，如果分不清“異常”，那麼至少在“正常”的、沒有意外的流程裡，絕對不要用“異常機制來代替”。否則，代碼可讀性、可維護性將是災難。

```java
// Java
​
try{
​
}catch(FileNotFoundException f){
​
}catch(IOException i){
​
}finally{
​
}
```

### 1 人造語義異常

如果主流程中存在一個連續的“闖關”pipeline（一組按順序的調用，成功執行才能執行下一個，否則都算失敗），那麼可以使用try塊來集中放置主流程代碼，catch塊來集中處理失敗情況，避免if-else箭頭形代碼。

```cpp
try {
    getSomeThing_1();
    getSomeThing_2();
    getSomeThing_3();
catch(Exception e) {
    // deal with it
}
```

### 2 情理中的意外，可恢復

前面提到的非法字元、找不到檔案、連接不上，基本是公認的“意外”情況，基本都使用拋出異常的方式，但是這種情況，通常都會進行捕獲，並進行恢復。

### 3 無法意料的致命意外，不可恢復。

通常這種情況是，程式自身已經沒有修復的空間，程式會中止：

* Bug：邏輯錯誤導致的溢位、除0；
* 致命錯誤：比如os產生的Error；

## Rust的Panic！

Rust裡沒有異常。但如果非要和異常機制進行對映，Rust可以說做的相當決絕。

Rust把錯誤分成了兩大類。

* 一類是不可修復錯誤，建議使用panic來處理。對於不可修復錯誤，本質上沒有辦法在程式執行階段做好處理的，那麼就應該用panic讓程式主動退出，由開發者來修復源碼，這是唯一合理的方案。
* 另外一類錯誤是可修復錯誤，一般使用返回值來處理。比如打開檔出錯這種問題，應該是設計階段能預計到的，可以在執行階段更好處理的問題，就適合採用這種方案。

### 0 正常，以返回值的形式。

相當於壓縮了上一節中的0、1、2項。沒有什麼情理中的意外，網絡連不上、檔案找不到、非法輸入，統統都用返回值的方式。

### 1 致命錯誤，不可恢復，非崩不可。

* 一旦存在不可恢復的錯誤，Rust使用Panic！巨集來終止程式（執行緒）。一旦Panic！巨集出手，基本沒得救（panic::catch\_unwind是個例外，稍後說）。執行時預設會進行stack unwind（棧反解），一層層上去，直到執行緒的頂端。
* 有些情況Panic！是你的程式所依賴的庫產生的，比如陣列越界存取時的實現。
* 另一種情況，是你自己的程式邏輯判斷產生了不可恢復的錯誤，可以手動觸發Panic！巨集來終止程式。Panic！的使用與throw很類似。

##  Rust的返回值Result

對於可恢復的錯誤，Rust一律使用返回值來進行檢查，而且提倡採用內建列舉Result，還在實踐層面給了一定的約束：對於返回值為Result型別的函式，呼叫方如果沒有進行接收，編譯期會產生警告。很多庫函式都通過Result來告知呼叫方執行結果，讓呼叫方來決定是否嚴重到了使用Panic！的程度。

```cpp
enum Result<T, E>{
    Ok(T),
    Err(E),
}
```

在Rust標準庫中，可以找到許多以Result命名的型別，它們通常是Result泛型的特定版本，比如File::open的返回值就是把T替換成了std::fs::File，把E替換成了std::io::Error。

### panic::catch\_unwind

```cpp
use std::panic;
​
let result = panic::catch_unwind(|| {
    println!("hello!");
});
assert!(result.is_ok());
​
let result = panic::catch_unwind(|| {
    panic!("oh no!");
});
assert!(result.is_err());
```

沒錯，它的行為幾乎就是try/catch了：panic！巨集被捕獲了，程式並也沒有掛，返回了Err。儘管如此，Rust的目的並不是讓它成為try/catch機制的實現，而是當Rust和其他程式語言互動時，避免其他語言程式碼塊throw出異常。所以呢，錯誤處理的正道還是用Result。

從catch\_unwind的名字上，需要留意下unwind這個限定詞，它意味著只有預設進行堆疊反解的panic可以被捕獲到，如果是設為直接終止程式的panic，就逮不住了。

## 基本錯誤處理

Rust用於錯誤處理的最基本的類型就是我們常見的Option&lt;T&gt;類型。

```cpp
impl str {
pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {}
}
```

這個方法當然是可能失敗的，它有可能找不到。為了表達“成功返回了一個值”以及“沒有返回值”這兩種情況，Option&lt;usize&gt;就是一個非常合理的選擇。







