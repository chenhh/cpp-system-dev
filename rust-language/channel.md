# 管道\(channel\)

## 簡介

Rust標準庫中還提供了另外一種執行緒之間的通信方式:mpsc。這部分的庫存儲在std::sync::mpsc這個模組中。

mpsc代表的是Multi-producer，single consumer FIFO queue，即多生產者單消費者先進先出佇列。這種執行緒之間的通信方式是在不同執行緒之間建立一個通信“管道”（channel），一邊發送消息，一邊接收消息，完成資訊交流。

## 異步管道

非同步管道是最常用的一種管道類型。它的特點是:發送端和接收端之間存在一個緩衝區，發送端發送資料的時候，是先將這個資料扔到緩衝區，再由接收端自己去取。因此，每次發送，立馬就返回了，發送端不用管資料什麼時候被接收端處理。

```rust
use std::sync::mpsc::channel;
use std::thread;
fn main() {
    // 建立channel
    let (tx, rx) = channel();
    thread::spawn(move || {
        for i in 0..10 {
            tx.send(i).unwrap();
        }
    });
    while let Ok(r) = rx.recv() {
        println!("received {}", r);
    }
}
```

子執行緒中的發送者不斷迴圈調用send方法，發送資料。在主執行緒中，我們使用接收者不斷調用recv方法接收資料。我們可以注意到，channel（）是一個泛型函數，Sender和Receiver都是泛型類型，且一組發送者和接收者必定是同樣的類型參數，因此保證了發送和接收端都是同樣的類型。因為Rust中的類型推導功能的存在，使我們可以在調用channel的時候不指定具體類型參數，而通過後續的方法調用，推導出正確的類型參數。

Sender和Receiver的泛型參數必須滿足T：Send約束。這個條件是顯而易見的：被發送的消息會從一個執行緒轉移到另外一個執行緒，這個約束是為了滿足執行緒安全。如果用戶指定的泛型參數沒有滿足條件，在編譯的時候會發生錯誤，提醒我們修復bug。

發送者調用send方法，接收者調用recv方法，返回類型都是Result類型，用於錯誤處理，因為它們都有可能調用失敗。當發送者已經被銷毀的時候，接收者調用recv則會返回錯誤；同樣，當接收者已經銷毀的時候，發送者調用send也會返回錯誤。

