# mod

## 簡介

mod（模組）是用於在crate內部繼續進行分層和封裝的機制。模組內部又可以包含模組。Rust中的模組是一個典型的樹形結構。每個crate會自動產生一個跟當前crate同名的模組，作為這個樹形結構的根節點。

在一個crate內部創建新模組的方式有下面幾種。

* 一個檔中創建內嵌模組。直接使用mod關鍵字即可，模組內容包含到大括弧內部：

```rust
mod name { fn items() {} … }
```

* 獨立的一個檔就是一個模組。檔案名即是模組名。
* 一個資料夾也可以創建一個模組。資料夾內部要有一個mod.rs文  件，這個檔就是這個模組的入口。

使用哪種方式編寫模組取決於當時的場景。

* 如果我們需要創建一個小型子模組，比如單元測試模組，那麼直接寫到一個檔內部就非常簡單而且直觀；
* 如果一個模組內容相對有點多，那麼把它單獨寫到一個檔內是更容易維護的；
* 如果一個模組的內容太多了，那麼把它放到一個資料夾中就更合理，因為我們可以把真正的內容繼續分散到更小的子模組中，而在mod.rs中直接重新匯出（re-export）。這樣mod.rs的源碼就大幅簡化，不影響外部的調用者。

## 範例

比如，我們有一個crate內部包含了兩個模組，一個是caller一個是worker。我們可以有幾種方案來實現。

方案一：直接把所有程式碼都寫到lib.rs裡面：

```rust
// <lib.rs>
mod caller {
    fn call() {}
}
mod worker {
    fn work1() {}
    fn work2() {}
    fn work3() {}
}
```

方案二：把這兩個模組分到兩個不同的檔中，分別叫作caller.rs和worker.rs。那麼我們的項目就有了三個檔，它們的內容分別是：

```rust
// <lib.rs>
mod caller;
mod worker;
// <caller.rs>
fn call() {}
// <worker.rs>
fn work1() {}
fn work2() {}
fn work3() {}
```

因為lib.rs是這個crate的入口，我們需要在這裡聲明它的所有子模組，否則caller.rs和worker.rs都不會被當成這個項目的源碼編譯。









