# 語句與表達式

## 語句\(statement\)

一個Rust程式，是從main函數開始執行的。而函數體內，則是由一條條語句組成的。Rust程式裡，運算式（Expression）和語句（Statement）是完成流程控制、計算求值的主要工具。

在Rust程式裡面，運算式可以是語句的一部分，反過來，語句也可以是運算式的一部分。

* 一個運算式總是會產生一個值，因此它必然有類型；
* 語句不產生值，它的類型永遠是（）。
* 如果把一個運算式加上分號，那麼它就變成了一個語句；
* 如果把語句放到一個語句塊中包起來，那麼它就可以被當成一個運算式使用。

## 表達式\(expression\)

“運算式”在Rust程式中佔據著重要位置，運算式的功能非常強大。Rust中的運算式語法具有非常好的“一致性”，每種運算式都可以嵌入到另外一種運算式中，組成更強大的運算式。

Rust的運算式包括**字面量運算式、方法調用運算式、陣列運算式、索引運算式、單目運算子運算式、雙目運算子運算式**等。

Rust運算式又可以分為“左值”（lvalue）和“右值”（rvalue）兩類。

* 所謂左值，意思是這個運算式可以表達一個記憶體位址。因此，它們可以放到設定運算子左邊使用。
* 其他的都是右值。

### 運算表達式

Rust的算術運算子包括：加（+）、減（-）、乘（\*）、除（/）、求餘數（%）。

```rust
fn main() {
    let x = 100;
    let y = 10;
    // 算數運算式計算後會回傳值
    println!("{} {} {} {} {}", x + y, x - y, x * y, x / y, x % y);
}
```

x+y、x-y這些都是算數運算運算式，它們都有自己的值和類型。常見的整數、浮點數類型都支援這幾種運算式。它們還可以被重載，讓自訂的類型也支援這幾種運算式。

Rust的比較運算子包括：等於（==）、不等於（！=）、小於（&lt;）、大於（&gt;）、小於等於（&lt;=）、大於等於（&gt;=）。比較運算子的兩邊必須是同類型的，並滿足PartialEq約束。比較運算式的類型是bool。另外，Rust禁止連續比較。

```rust
fn main() {
    let (a, b, c) = (true, true, false);
    // error: comparison operators cannot be chained
    //   a == b == c;
    a == b && b == c;
}
```



### bitwise運算子

```rust
fn main() {
    let num1: u8 = 0b_1010_1010;
    let num2: u8 = 0b_1111_0000;
    println!("{:08b}", !num1);       //01010101
    println!("{:08b}", num1 & num2); //10100000
    println!("{:08b}", num1 | num2); //11111010
    println!("{:08b}", num1 ^ num2); //01011010
    println!("{:08b}", num1 << 4);   //10100000
    println!("{:08b}", num1 >> 4);   //00001010
}
```

### logical運算子

取反運算子\(!\)既支援“邏輯取反”也支援“按位元取反”，它們是同一個運算子，根據類型決定執行哪個操作。如果被運算元是bool類型，那麼就是邏輯取反；如果被運算元是其他數字類型，那麼就是按位元取反。

bool類型既支援“邏輯AND”、“邏輯OR”，也支援“按位元AND”、“按位元OR”。它們的區別在於，“邏輯AND”、“邏輯OR”具備“短路”功能。

Rust裡面的運算子優先順序與C語言裡面的運算子優先順序設置是不一樣的，有些細微的差別。不過這並不是很重要。不論在哪種程式設計語言中，建議如果碰到複雜一點的運算式，儘量用小括弧明確表達計算順序，避免依賴語言預設的運算子優先順序。因為不同知識背景的程式師對運算子優先順序順序的記憶是不同的。

```rust
fn f1() -> bool {
    println!("Call f1");
    true
}
fn f2() -> bool {
    println!("Call f2");
    false
}
fn main() {
    // call f2, call f1, Bit AND: false
    println!("Bit AND: {}\n", f2() & f1()); 
    
    // call f2, Logic AND: false (f1因為短路沒有被執行)
    println!("Logic AND: {}\n", f2() && f1()); 
    
    // call f1, call f2, bit OR: true
    println!("Bit OR: {}\n", f1() | f2());
    
    // call f1, logic OR: true (f2因為短路沒有被執行)
    println!("Logic OR: {}\n", f1() || f2());
}
```

### 賦值表達式

一個左值運算式、設定運算子（=）和右值運算式，可以構成一個賦值運算式。

```rust
// 聲明區域變數,帶 mut 修飾
let mut x : i32 = 1;
// x 是 mut 綁定,所以可以為它重新賦值
x = 2;
```

